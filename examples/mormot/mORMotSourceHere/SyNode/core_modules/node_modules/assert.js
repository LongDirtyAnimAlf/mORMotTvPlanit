// Originally from narwhal.js (http://narwhaljs.org)
// Copyright (c) 2009 Thomas Robinson <280north.com>

/**
 * This module is used for writing unit tests for your applications, you can access it with `require('assert')`.
 * This is port of NodeJS {@link http://nodejs.org/api/assert.html NodeJS.assert} module - see detailed documentation there
 *
 * @module assert
 */
var util = require('util');
var pSlice = Array.prototype.slice;

// 1. The assert module provides functions that throw
// AssertionError's when particular conditions are not met. The
// assert module must conform to the following interface.
/**
 * Tests if value is truthy, it is equivalent to assert.equal(true, !!value, message);
 */
var assert = module.exports = ok;

// 2. The AssertionError is defined in assert.
// new assert.AssertionError({ message: message,
//                             actual: actual,
//                             expected: expected })

/*
assert.AssertionError = function AssertionError(options) {
  this.name = 'AssertionError';
  this.actual = options.actual;
  this.expected = options.expected;
  this.operator = options.operator;
  this.message = options.message || getMessage(this);
  this.stack1 = this.stack;
    var stackStartFunction = options.stackStartFunction || fail;
  //MPV Error.captureStackTrace(this, stackStartFunction);
};

// assert.AssertionError instanceof Error
util.inherits(assert.AssertionError, Error);
//assert.AssertionError.prototype = new Error();
//assert.AssertionError.prototype.constructor = assert.AssertionError;
 */

// MPV this realisation is specific for SpiderMonkey
// in case we not create real new Error() we do not get stack of error
assert.AssertionError = function(options){
    var tmp_stack = (new Error).stack.split("\n").slice(1),
    re = /^(.*?)@(.*?):(.*?)$/.exec( tmp_stack[1] ); //[undef, undef, this.fileName, this.lineNumber] = re
    this.fileName = re[2];
    this.lineNumber = re[3];
    this.stack = tmp_stack.join("\n");
    this.actual = options.actual;
    this.expected = options.expected;
    this.operator = options.operator;
    this.message =  options.message || getMessage(this);
};

assert.AssertionError.prototype = {
    __proto__: Error.prototype,
    name: 'AssertionError',
    constructor: assert.AssertionError
};

function replacer(key, value) {
  if (value === undefined) {
    return '' + value;
  }
  if (typeof value === 'number' && (isNaN(value) || !isFinite(value))) {
    return value.toString();
  }
  if (typeof value === 'function' || value instanceof RegExp) {
    return value.toString();
  }
  return value;
}

function truncate(s, n) {
  if (typeof s == 'string') {
    return s.length < n ? s : s.slice(0, n);
  } else {
    return s;
  }
}

function getMessage(self) {
  return truncate(JSON.stringify(self.actual, replacer), 128) + ' ' +
         self.operator + ' ' +
         truncate(JSON.stringify(self.expected, replacer), 128);
}

// At present only the three keys mentioned above are used and
// understood by the spec. Implementations or sub modules can pass
// other keys to the AssertionError's constructor - they will be
// ignored.

// 3. All of the following functions must throw an AssertionError
// when a corresponding condition is not met, with a message that
// may be undefined if not provided.  All assertion methods provide
// both the actual and expected values to the assertion error for
// display purposes.

/**
 * Throws an exception that displays the values for actual and expected separated by the provided operator.
 * @param actual
 * @param expected
 * @param message
 * @param operator
 * @param stackStartFunction
 */
function fail(actual, expected, message, operator, stackStartFunction) {
  throw new assert.AssertionError({
    message: message,
    actual: actual,
    expected: expected,
    operator: operator,
    stackStartFunction: stackStartFunction
  });
}

// EXTENSION! allows for well behaved errors defined elsewhere.
assert.fail = fail;

// 4. Pure assertion tests whether a value is truthy, as determined
// by !!guard.
// assert.ok(guard, message_opt);
// This statement is equivalent to assert.equal(true, !!guard,
// message_opt);. To test strictly for the value true, use
// assert.strictEqual(true, guard, message_opt);.
/**
 * Tests if value is truthy, it is equivalent to assert.equal(true, !!value, message);
 * @param value
 * @param message
 */
function ok(value, message) {
  if (!!!value) fail(value, true, message, '==', assert.ok);
}
assert.ok = ok;

// 5. The equality assertion tests shallow, coercive equality with
// ==.
// assert.equal(actual, expected, message_opt);
/**
 * Tests shallow, coercive equality with the equal comparison operator ( == ).
 * @param actual
 * @param expected
 * @param {String} [message]
 */
module.exports.equal = function equal(actual, expected, message) {
  if (actual != expected) fail(actual, expected, message, '==', assert.equal);
};

// 6. The non-equality assertion tests for whether two objects are not equal
// with != assert.notEqual(actual, expected, message_opt);
/**
 * Tests shallow, coercive non-equality with the not equal comparison operator ( != ).
 * @param actual
 * @param expected
 * @param [message]
 */
module.exports.notEqual = function notEqual(actual, expected, message) {
  if (actual == expected) {
    fail(actual, expected, message, '!=', assert.notEqual);
  }
};

// 7. The equivalence assertion tests a deep equality relation.
// assert.deepEqual(actual, expected, message_opt);
/**
 * Tests for deep equality.
 * @param actual
 * @param expected
 * @param [message]
 */
module.exports.deepEqual = function deepEqual(actual, expected, message) {
  if (!_deepEqual(actual, expected)) {
    fail(actual, expected, message, 'deepEqual', assert.deepEqual);
  }
};

function _deepEqual(actual, expected) {
  // 7.1. All identical values are equivalent, as determined by ===.
  if (actual === expected) {
    return true;

// UB SEPCIFIC
//  } else if (Buffer.isBuffer(actual) && Buffer.isBuffer(expected)) {
//    if (actual.length != expected.length) return false;
//
//    for (var i = 0; i < actual.length; i++) {
//      if (actual[i] !== expected[i]) return false;
//    }
//
//    return true;
  } else if (actual instanceof ArrayBuffer && expected instanceof ArrayBuffer) {
          if (actual.byteLength != expected.byteLength) return false;
          var aBuf = new Uint8Array(actual), eBuf = new Uint8Array(expected);

          for (var i = 0; i < aBuf.length; i++) {
            if (aBuf[i] !== eBuf[i]) return false;
          }

          return true;

  // 7.2. If the expected value is a Date object, the actual value is
  // equivalent if it is also a Date object that refers to the same time.
  } else if (actual instanceof Date && expected instanceof Date) {
    return actual.getTime() === expected.getTime();

  // 7.3 If the expected value is a RegExp object, the actual value is
  // equivalent if it is also a RegExp object with the same source and
  // properties (`global`, `multiline`, `lastIndex`, `ignoreCase`).
  } else if (actual instanceof RegExp && expected instanceof RegExp) {
    return actual.source === expected.source &&
           actual.global === expected.global &&
           actual.multiline === expected.multiline &&
           actual.lastIndex === expected.lastIndex &&
           actual.ignoreCase === expected.ignoreCase;

  // 7.4. Other pairs that do not both pass typeof value == 'object',
  // equivalence is determined by ==.
  } else if (typeof actual != 'object' && typeof expected != 'object') {
    return actual == expected;

  // 7.5 For all other Object pairs, including Array objects, equivalence is
  // determined by having the same number of owned properties (as verified
  // with Object.prototype.hasOwnProperty.call), the same set of keys
  // (although not necessarily the same order), equivalent values for every
  // corresponding key, and an identical 'prototype' property. Note: this
  // accounts for both named and indexed properties on Arrays.
  } else {
    return objEquiv(actual, expected);
  }
}

function isUndefinedOrNull(value) {
  return value === null || value === undefined;
}

function isArguments(object) {
  return Object.prototype.toString.call(object) == '[object Arguments]';
}

function objEquiv(a, b) {
  if (isUndefinedOrNull(a) || isUndefinedOrNull(b))
    return false;
  // an identical 'prototype' property.
  if (a.prototype !== b.prototype) return false;
  //~~~I've managed to break Object.keys through screwy arguments passing.
  //   Converting to array solves the problem.
  if (isArguments(a)) {
    if (!isArguments(b)) {
      return false;
    }
    a = pSlice.call(a);
    b = pSlice.call(b);
    return _deepEqual(a, b);
  }
  try {
    var ka = Object.keys(a),
        kb = Object.keys(b),
        key, i;
  } catch (e) {//happens when one is a string literal and the other isn't
    return false;
  }
  // having the same number of owned properties (keys incorporates
  // hasOwnProperty)
  if (ka.length != kb.length)
    return false;
  //the same set of keys (although not necessarily the same order),
  ka.sort();
  kb.sort();
  //~~~cheap key test
  for (i = ka.length - 1; i >= 0; i--) {
    if (ka[i] != kb[i])
      return false;
  }
  //equivalent values for every corresponding key, and
  //~~~possibly expensive deep test
  for (i = ka.length - 1; i >= 0; i--) {
    key = ka[i];
    if (!_deepEqual(a[key], b[key])) return false;
  }
  return true;
}

// 8. The non-equivalence assertion tests for any deep inequality.
// assert.notDeepEqual(actual, expected, message_opt);
/**
 * Tests for any deep inequality.
 * @param actual
 * @param expected
 * @param [message]
 */
module.exports.notDeepEqual = function notDeepEqual(actual, expected, message) {
  if (_deepEqual(actual, expected)) {
    fail(actual, expected, message, 'notDeepEqual', assert.notDeepEqual);
  }
};

// 9. The strict equality assertion tests strict equality, as determined by ===.
// assert.strictEqual(actual, expected, message_opt);
/**
 * Tests strict equality, as determined by the strict equality operator ( === )
 * @param actual
 * @param expected
 * @param [message]
 */
module.exports.strictEqual = function strictEqual(actual, expected, message) {
  if (actual !== expected) {
    fail(actual, expected, message, '===', assert.strictEqual);
  }
};

// 10. The strict non-equality assertion tests for strict inequality, as
// determined by !==.  assert.notStrictEqual(actual, expected, message_opt);
/**
 * Tests strict non-equality, as determined by the strict not equal operator ( !== )
 * @param actual
 * @param expected
 * @param [message]
 */
module.exports.notStrictEqual = function notStrictEqual(actual, expected, message) {
  if (actual === expected) {
    fail(actual, expected, message, '!==', assert.notStrictEqual);
  }
};

function expectedException(actual, expected) {
  if (!actual || !expected) {
    return false;
  }

  if (Object.prototype.toString.call(expected) == '[object RegExp]') {
    return expected.test(actual);
  } else if (actual instanceof expected) {
    return true;
  } else if (expected.call({}, actual) === true) {
    return true;
  }

  return false;
}

function _throws(shouldThrow, block, expected, message) {
  var actual;

  if (typeof expected === 'string') {
    message = expected;
    expected = null;
  }

  try {
    block();
  } catch (e) {
    actual = e;
  }

  message = (expected && expected.name ? ' (' + expected.name + ').' : '.') +
            (message ? ' ' + message : '.');

  if (shouldThrow && !actual) {
    fail(actual, expected, 'Missing expected exception' + message);
  }

  if (!shouldThrow && expectedException(actual, expected)) {
    fail(actual, expected, 'Got unwanted exception' + message);
  }

  if ((shouldThrow && actual && expected &&
      !expectedException(actual, expected)) || (!shouldThrow && actual)) {
    throw actual;
  }
}

// 11. Expected to throw an error:
// assert.throws(block, Error_opt, message_opt);
/**
 * Expects block to throw an error. error can be constructor, RegExp or validation function.
 *
 * Validate instanceof using constructor:
 *
 *      assert.throws(function() {
 *         throw new Error("Wrong value");
 *      }, Error);
 *
 * Validate error message using RegExp:
 *
 *      assert.throws(function() {
 *         throw new Error("Wrong value");
 *      }, /error/);
 *
 * Custom error validation:
 *
 *      assert.throws(
 *      function() {
 *         throw new Error("Wrong value");
 *       },
 *      function(err) {
 *         if ( (err instanceof Error) && /value/.test(err) ) {
 *           return true;
 *         }
 *       },
 *      "unexpected error"
 *      );
 *
 * @param block
 * @param [error]
 * @param [message]
 */
module.exports.throws = function(block, /*optional*/error, /*optional*/message) {
  _throws.apply(this, [true].concat(pSlice.call(arguments)));
};

// EXTENSION! This is annoying to write outside this module.
/**
 * Expects block not to throw an error, see assert.throws for details.
 * @param block
 * @param [message]
 */
module.exports.doesNotThrow = function(block, /*optional*/message) {
  _throws.apply(this, [false].concat(pSlice.call(arguments)));
};

/**
 * Tests if value is not a false value, throws if it is a true value. Useful when testing the first argument, error in callbacks.
 * @param err
 */
module.exports.ifError = function(err) { if (err) {throw err;}};
